# Id_Generator
该类库实现了高性能分布式ID生成，在相同运行环境下，该ID生成器比SNOWFLAKE快30倍，这得益于它的无锁设计。
生成的ID是long型整数,其格式为: 0 + 当前距2020年的年数（7位） + 自增序号(41位) + 启动序号(7位) + 服务器标识(8位)
根据需要，每一部分的长度都可以通过构造方法自定义。
  自增序号：自增序号在程序中是通过AtomicLong实现的。自增序号(41)表示每次生成ID时，截取AtomicLong当前值的后41位
  启动序号（7位）表示系统支持一年中重启127次，每重启一次，启动序号都会自动加1，通过启动序号避免了重启后生成ID可能
  重复的问题。
  服务器标识(8位) 表示生成ID时，截取服务器标识数字的后8位，服务器标识(8)最多支持256台服务器构成的集群。
  
设计思路：
  设计时之所以没有采用{毫秒数 + 自增序号 + 服务器标识}格式，是因为这种格式有种缺陷，它需要你知道你系统的访问峰值是多少，
  这样才好给自增序号留足够的空间。SNOWFLAKE默认情况下1ms最多能生成4096个ID，这在平常肯定是没问题，但遇到"双十一"这种节日，
  生成的时候就可能会出现等待（达到上限）。当然可以通过调节，让它每ms最多能生成的ID更多，让它尽量少等，但并不能完全避免等待的
  情况发生。SNOWFLAKE在面对不可预料的高并发访问时(虽然很多系统有限流)，有时表现就不那么好。而且由于生成ID的方法因为可能出现
  并发问题而加锁，性能也会打折扣。
  用{年 + 自增序号 + 启动序号 +服务器标识}这种格式，就不用考虑抢购这种情况的发生，偶尔公司会做活动，
  但不可能时时刻刻都做活动。单台服务器上41位的自增序号能支持一年中生成21990 2325 5552个ID。
  还有一点要说明的，也是这个实现中最重要的一点，就是直接截取自增序号的后多少位，而不是当自增序号的值到达某个值时，就让它归零,
  这里和SNOWFLAKE不一样。这是基于一个事实，当一个整数自增不断变大的过程中，它的低位数也是在跟着变化的，而且是循环变化的。以
  10进制讲解，观察0增加到100时的个位数变化，会发现个位数从0变到9后再从0变到9
  
